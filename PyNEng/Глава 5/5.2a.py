"""
Всё, как в задании 5.2, но, если пользователь ввел адрес хоста, а не адрес сети, надо преоб-
разовать адрес хоста в адрес сети и вывести адрес сети и маску, как в задании 5.2.

Пример адреса сети (все биты хостовой части равны нулю):

• 10.0.1.0/24
• 190.1.0.0/16

Пример адреса хоста:
• 10.0.1.1/24 - хост из сети 10.0.1.0/24
• 10.0.5.195/28 - хост из сети 10.0.5.192/28

Если пользователь ввел адрес 10.0.1.1/24, вывод должен быть таким:
Network:
10       0        1        0
00001010 00000000 00000001 00000000
Mask:
/24
255      255      255      0
11111111 11111111 11111111 00000000

Проверить работу скрипта на разных комбинациях хост/маска, например: 10.0.5.195/28,
10.0.1.1/24

Подсказка:
Есть адрес хоста в двоичном формате и маска сети 28. Адрес сети это первые 28 бит адре-
са хоста + 4 ноля. То есть, например, адрес хоста 10.1.1.195/28 в двоичном формате будет
bin_ip = "00001010000000010000000111000011".

А адрес сети будет первых 28 символов из bin_ip + 0000 (4 потому что всего в адресе может
быть 32 бита, а 32 - 28 = 4): 00001010000000010000000111000000
"""
network = input('Введите сеть в формате 10.10.10.0/24: ')

# Заменяем "." и "/" на ","
network = network.replace('.', ',').replace('/', ',')
network_parts = network.split(",")


# Получаем IP-адрес и маску
ip_address = list(map(int, network_parts[:4]))  # Преобразуем первые четыре части в int
mask_length = int(network_parts[4])  # Пятая часть - это длина маски
print(ip_address)
print(mask_length)

# Создаем двоичную маску
mask_binary = "1" * mask_length + "0" * (32 - mask_length)
print('mask: ', mask_binary)

ip_address_binary = (
    f"{ip_address[0]:08b}" +
    f"{ip_address[1]:08b}" +
    f"{ip_address[2]:08b}" +
    f"{ip_address[3]:08b}"
)

print('ip_address: ', ip_address_binary)
network = ip_address_binary[:mask_length] #убираем первые символы
print('убрали первые цифры ', network)
network = network.ljust(32, '0') #добавляем недостающие нули в конец
print('добавили до 32 символа ', network)
print('network: ', network)

# Преобразуем двоичную сеть в десятичный формат
network_01 = int(network[0:8], 2)
network_02 = int(network[8:16], 2)
network_03 = int(network[16:24], 2)
network_04 = int(network[24:32], 2)

network = [network_01, network_02, network_03, network_04]

print('network: ', network)

# Преобразуем двоичную маску в десятичный формат
mask_01 = int(mask_binary[0:8], 2)
mask_02 = int(mask_binary[8:16], 2)
mask_03 = int(mask_binary[16:24], 2)
mask_04 = int(mask_binary[24:32], 2)



print('\n' + '-' * 40)

ip_template = '''
Network:
{0:<11} {1:<11} {2:<11} {3:<11}
{0:<011b} {1:<011b} {2:<011b} {3:<011b}

Mask:
/{4:<11}
{9:<11} {10:<11} {11:<11} {12:<11}
{5:<011} {6:<011} {7:<011} {8:<011}
'''

#выводим шаблон и подставляем в него даные из переменной ip
print(ip_template.format(network[0], network[1], network[2], network[3], mask_length, mask_binary[0:8], mask_binary[8:16], mask_binary[16:24], mask_binary[24:32], mask_01, mask_02, mask_03, mask_04))
